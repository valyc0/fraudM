input {
  file {
    path => "/data/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    mode => "read"
    file_completed_action => "log"
    file_completed_log_path => "/data/completed_files.log"
    sincedb_clean_after => "2 days"
    codec => plain {
      charset => "UTF-8"
    }
    discover_interval => "5"
  }
}

filter {
  csv {
    separator => ","
    skip_header => true
    columns => ["tenant", "val_euro", "duration", "economicUnitValue", "other_party_country", "routing_dest", "service_type__desc", "op35", "carrier_in", "carrier_out", "selling_dest", "raw_caller_number", "raw_called_number", "paese_destinazione", "event_timestamp", "xdrid"]
    skip_empty_columns => true
  }

  mutate {
    convert => {
      "val_euro" => "float"
      "duration" => "integer"
      "economicUnitValue" => "float"
    }
  }

  # Handle timestamp
  date {
    match => [ "event_timestamp", "ISO8601" ]
    target => "@timestamp"
    timezone => "Europe/Rome"
  }

  # Clean up fields
  mutate {
    remove_field => ["path", "host", "@version", "message", "@metadata"]
  }

  # Add event type
  mutate {
    add_field => { "event_type" => "call_record" }
  }

  # Add current timestamp when saving to Kafka
  ruby {
    code => "event.set('kafka_timestamp', Time.now.iso8601)"
  }

  # Keep only the fields we want to send to Kafka
  mutate {
    add_field => {
      "keep_tenant" => "%{tenant}"
      "keep_val_euro" => "%{val_euro}"
      "keep_duration" => "%{duration}"
      "keep_economicUnitValue" => "%{economicUnitValue}"
      "keep_other_party_country" => "%{other_party_country}"
      "keep_routing_dest" => "%{routing_dest}"
      "keep_service_type__desc" => "%{service_type__desc}"
      "keep_op35" => "%{op35}"
      "keep_carrier_in" => "%{carrier_in}"
      "keep_carrier_out" => "%{carrier_out}"
      "keep_selling_dest" => "%{selling_dest}"
      "keep_raw_caller_number" => "%{raw_caller_number}"
      "keep_raw_called_number" => "%{raw_called_number}"
      "keep_paese_destinazione" => "%{paese_destinazione}"
      "keep_event_timestamp" => "%{event_timestamp}"
      "keep_xdrid" => "%{xdrid}"
      "keep_timestamp" => "%{@timestamp}"
      "keep_event_type" => "%{event_type}"
      "keep_kafka_timestamp" => "%{kafka_timestamp}"
    }
  }

  # Remove all original fields
  mutate {
    remove_field => ["[^keep_]"]
  }

  # Rename kept fields back to original names
  mutate {
    rename => {
      "keep_tenant" => "tenant"
      "keep_val_euro" => "val_euro"
      "keep_duration" => "duration"
      "keep_economicUnitValue" => "economicUnitValue"
      "keep_other_party_country" => "other_party_country"
      "keep_routing_dest" => "routing_dest"
      "keep_service_type__desc" => "service_type__desc"
      "keep_op35" => "op35"
      "keep_carrier_in" => "carrier_in"
      "keep_carrier_out" => "carrier_out"
      "keep_selling_dest" => "selling_dest"
      "keep_raw_caller_number" => "raw_caller_number"
      "keep_raw_called_number" => "raw_called_number"
      "keep_paese_destinazione" => "paese_destinazione"
      "keep_event_timestamp" => "event_timestamp"
      "keep_xdrid" => "xdrid"
      "keep_timestamp" => "@timestamp"
      "keep_event_type" => "event_type"
      "keep_kafka_timestamp" => "kafka_timestamp"
    }
  }
}

output {
  kafka {
    bootstrap_servers => "kafka:29092"
    topic_id => "call-data-raw"
    codec => json
    message_key => "%{xdrid}"
    value_serializer => "org.apache.kafka.common.serialization.StringSerializer"
  }
}