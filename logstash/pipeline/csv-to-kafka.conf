input {
  file {
    path => "/data/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    mode => "read"
    file_completed_action => "log"
    file_completed_log_path => "/data/completed_files.log"
    sincedb_clean_after => "2 days"
    codec => plain {
      charset => "UTF-8"
    }
    discover_interval => "5"
  }
}

filter {
  csv {
    separator => ","
    skip_header => true
    columns => ["tenant", "val_euro", "duration", "economicUnitValue", "other_party_country", "routing_dest", "service_type__desc", "op35", "carrier_in", "carrier_out", "selling_dest", "raw_caller_number", "raw_called_number", "paese_destinazione", "event_timestamp", "xdrid"]
    skip_empty_columns => true
  }

  mutate {
    convert => {
      "val_euro" => "float"
      "duration" => "integer"
      "economicUnitValue" => "float"
    }
  }

  # Handle timestamp
  date {
    match => [ "event_timestamp", "ISO8601" ]
    target => "@timestamp"
    timezone => "Europe/Rome"
  }

  # Clean up fields
  mutate {
    remove_field => ["path", "host", "@version", "message", "@metadata"]
  }

  # Add event type
  mutate {
    add_field => { "event_type" => "call_record" }
  }

  # Add current timestamp when saving to Kafka
  ruby {
    code => "event.set('kafka_timestamp', Time.now.iso8601)"
  }
}

output {
  kafka {
    bootstrap_servers => "kafka:29092"
    topic_id => "call-data-raw"
    codec => json
    message_key => "%{xdrid}"
    value_serializer => "org.apache.kafka.common.serialization.StringSerializer"
    include_fields => ["tenant", "val_euro", "duration", "economicUnitValue", "other_party_country", "routing_dest", "service_type__desc", "op35", "carrier_in", "carrier_out", "selling_dest", "raw_caller_number", "raw_called_number", "paese_destinazione", "event_timestamp", "xdrid", "@timestamp", "event_type", "kafka_timestamp"]
  }
}